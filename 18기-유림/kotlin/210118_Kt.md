> 깡쌤의 코틀린 프로그래밍 4-5장 84-131p
>
> 저자: 강성윤

## 4. 변수와 함수

### 4.1. 변수 선언 및 초기화

#### 4.1.1. 변수 선언법

val(혹은 var) 변수명: 타입 = 값

val(value)은 Assign-once 변수로 한 번 초기화하면 더는 변경할 수 없다. 그렇지만 상수변수라고 확정지을 수는 없다. 값은 변경할 수 없지만 매번 출력되는 값은 다르게 할 수 있기 때문이다. 이는 코틀린에서 변수는 프로퍼티이기 때문이다. 그래서 읽기 전용 변수라는 표현이 맞다.

var(variable)는 Mutable 변수로 언제든지 변경할 수 있다.

변수명 뒤에 콜론을 구분자로 타입을 입력한다. 변수를 선언할 때 타입을 명시하지 않으면 대입하는 초깃값에 따라 적절한 타입으로 알아서 적용된다. 코틀린에서 알아서 값을 유추해 타입을 적용하는 것을 '타입 추론'이라고 한다.

#### 4.1.2. 변수 초기화

변수 선언은 최상위(클래스 외부), 클래스 내부, 함수 내부에 할 수 있다. 변수는 자동으로 초기화되지 않으므로 코드에서 직접 초기화해야 한다. 최상위 레벨이나 클래스의 멤버 변수는 반드시 선언과 동시에 초기화해주어야 한다. 함수 내부의 지역번수는 선언과 동시에 초기화하지 않더라도 이후에 따로 초기화해야지만 사용할 수 있다.

#### 4.1.3. null이 될 수 있는 변수와 null

코틀린에서 null값을 대입하려면 명시적으로 null이 될 수 있는 (nullable) 변수로 선언해야 한다. 코틀린에서 null을 대입할 수 없는 변수와 있는 변수로 구분하여 사용하는 것을 null 안전성이라고 한다. null에 안전한 프로그램을 작성하기 위한 기법이다. null처리를 쉽게, null로 인해 발생하는 다양한 문제에 대응하는 프로그램을 작성하게 하자는 개념이다.

```kotlin
var nullableData1: String? = null
// 물음표 기호가 없는 변수는 초깃값이 null이 될 수 없음! 또한, 값을 변경하려면 var로 선언
```

#### 4.1.4. 상수변수 선언

`const val myConst: Int = 10`

const는 이용에 제약사항이 많다. var변수에 const 예약어를 사용하는 것은 이치상 의미가 없으므로 에러다. 클래스, 함수 내부에서는 const로 변수를 선언할 수 없다. 변수를 최상위 레벨로 선언하거나 object로 선언한 클래스에서만 사용할 수 있다. const는 값을 변경할 수 없으므로 객체별로 데이터를 다르게 표현할 수 없는데, 굳이 클래스 내부에 선언할 필요도 없다.

### 4.2. 함수 사용법

#### 4.2.1. 함수 선언

`fun 함수명(매개변수명: 타입) : 반환타입 { }`

함수의 매개변수는 무조건 val로 적용된다. 함수 내에서 매개변수 값을 변경할 수 없다. 함수 선언에서 의미있는 반환값이 없을 때는 Unit으로 명시한다. 이는 생략 가능하며 함수의 반환 타입이 선언되지 않으면 기본으로 적용된다.

함수 내에 함수를 정의할 수 있다. 특정 함수 내에 선언된 함수는 그 함수의 지역변수와 비슷한 개념으로 이용된다. 만약 sum() 내에 calSum()이 선언되어있다면 sum() 외부에서는 calSum()을 선언할 수 없다.

함수 선언 때 단일 구문으로 값을 반환하는 함수라면 중괄호 {}을 생략하고, 등호 =을 이용해 쉽게 정의할 수 있다. 단일 구문으로 값을 반환하는 함수라는 것은 함수 내의 내용이 값을 반환하는 한 줄로 작성된 함수를 의미한다.

```kotlin
fun some(a: Int, b: Int): Int {
    return a + b
}

fun some(a: Int, b: Int): Int = a + b
// 반환 타입도 생략할 수 있다. 컴파일러가 유추해서 정해준다.
```

#### 4.2.2. 함수 오버로딩

같은 이름의 함수를 매개변수 부분을 다르게 하여(매개변수의 개수나 타입이 상이) 여러 개 정의하는 기법.

#### 4.2.3. 기본 인수와 명명된 인수

함수에 매개변수가 있으면 호출하는 곳에서는 호출받는 함수의 매개변수 타입과 개수에 맞추어 호출해야 한다. 이 때 피호출자의 매개변수 정보에 맞게 호출자가 전달하는 값을 인수라고 한다. 즉, 피호출자는 호출자가 전달하는 인수를 매개변수로 받는다.

그런데 호출자가 인수를 명시하지 않아도 피호출자가 알아서 기본값을 적용하게 할 수 있다. 이를 기본 인수 라고 한다.

```kotlin
// 일반 함수
fun sayHello(name: String) {
    println("Hello!!" + name)
}
// 기본 인수 - 함수에서 인수의 기본값을 가짐
fun sayHello(name: String = "kkang") {
    println("Hello!!" + name)
}
// 명명된 인수 - 호출자에서 전달할 값을 대입할 매개변수명을 명시
fun sayHello(name: String = "kkang", no: Int) {
    println("Hello!!" + name)
}
sayHello(no=10)
```

#### 4.2.4. 중위 표현식

```kotlin
infix fun Int.myFun(x: Int): Int {
    return x * x
}
class FunClass {
    infix fun infixFun(a: Int) {
        println("infixFun call")
    }
}
fun main(args: Array<String>) {
    val obj = FunClass()
    obj.infixFun(10)
    obj infixFun 10
}
```

중위 표현식으로 이용할 수 있는 경우

- 클래스의 멤버 함수로 선언하거나 클래스의 확장 함수일 때
- 매개변수가 하나인 함수일 때

#### 4.2.5. 가변 인수

함수 오버로딩에 의해 너무 많은 함수가 선언되어 개발을 불편하게 할 수 있다. 이 때 함수를 가변 인수를 포함하는 함수로 선언하면 쉽게 작성할 수 있다.

```kotlin
fun <T> varargsFun(a1: Int, vararg array: T) {
    
}
```

가변 인수를 포함하는 함수는 vararg라는 예약어를 이용하여 선언한다. 함수의 매개변수 선언 부분에 vararg를 이용하여 가변 인수를 지정한다. 이러한 함수를 호출할 때는 반드시 첫 번째 인수로 Int 타입의 데이터를 지정해야 하지만, 두 번째부터는 아무렇게나 지정해도 된다.

가변 인수는 명시적으로 타입을 지정하는 방법이 아니므로 제네릭을 이용해야 한다. 위의 코드에서 <T>, vararg array: T 등 T로 표현된 부분이 제네릭이다. 여기서는 타입을 명시할 수 없어서 임의의 타입(형식 타입)으로 선언한 것으로 정의해 둔다.

#### 4.2.6. 재귀함수

코틀린에서는 tailrec이라는 예약어를 통해 조금 더 효율적인 재귀함수를 만들 수 있다.

```kotlin
tailrec fun tailrecPrint(no: Int = 1, count: Int = 1) {
    println("tailrecPrint..")
    return if (no == count) return else tailrecPrint(no - 1, count)
}
```

일반적인 재귀함수와 사용법과 로직의 차이는 없어보인다. 하지만 소스코드가 자바로 변경될 때 재귀함수가 아닌 일반적인 반복문으로 변형된다. 재귀 함수의 StackoverflowError의 위험 부담에서 벗어날 수 있다.

유의할 점은 tailrec 재귀함수에서 자신을 다시 호출하는 구문은 함수의 맨 마지막 작업으로 작성해야 한다. 그래서 꼬리 재귀함수다.

## 5. 데이터 타입

### 5.1. 기초 데이터 타입

#### 5.1.1. 숫자 타입

Int, Double은 클래스이며 이 클래스로 타입을 명시하여 선언한 변수는 그 자체로 객체가 된다.

코틀린에서는 숫자 타입에 대입되는 데이터에 밑줄(_)을 추가할 수 있다. 숫자를 읽기 좋게 표현하기 위한 표현식이며 값에 영항을 주지 않는다.

#### 5.1.2. 논리, 문자와 문자열 타입

|| 논리합 && 논리곱 ! 부정

char은 ''로 묶어서 표현, number타입으로 표현되지 않음

string은 ""로 묶거나(escaped string), " " " 로 묶는다(raw string - 키보드에서 입력한 엔터 등의 값이 문자열에 그대로 적용).

문자열 템플릿 개념으로 문자열 내에 변수의 데이터나 특정 연산식 결과에 의한 데이터를 $ 기호로 쉽게 포함할 수 있다. "$변수명, ${표현식}" 으로 작성한다.

#### 5.1.3. Any 타입

어떤 타입의 데이터도 대입할 수 있는 타입.

when절에서 때에 따라 다양한 타입의 데이터로 이용할 때 사용.

#### 5.1.4. null 허용 타입

null이 대입될 가능성이 있는 곳에는 명시적으로 nullable을 표현해야 한다.

#### 5.1.5. Any, Any? 타입

Any 타입으로 선언한 변수에는 null을 대입할 수 없지만,

Any? 타입으로 선언한 변수에는 null을 대입할 수 있다.

Any 타입의 프로퍼티는 Any? 타입에 대입할 수 있을까? 있다.

Any? 타입의 프로퍼티는 Any 타입에 대입할 수 있을까? 없다.

#### 5.1.6. Unit과 Nothing

Unit은 흔히 함수의 반환 구문이 없다는 것을 표현. void와 비슷하다고 보면 됨.

Nothing은 의미 있는 데이터가 없다는 것을 명시적으로 선언하기 위해 사용하는 타입.

제네릭에서 중요한 개념

#### 5.1.7. 타입 확인과 캐스팅

타입 확인 연산자 is, 만약 특별한 타입으로 확인되면 명시적으로 타입 캐스팅(형변환)을 하지 않아도 컴파일러가 자동으로 캐스팅한다. -> 스마트 캐스트

코틀린은 기초 데이터 타입에 대한 자동 형 변환을 제공하지 않는다. Int 타입의 데이터를 Double 타입 변수에 대입하려고 하면 에러가 발생한다. toXXX() 함수를 통해 명시적으로 진행해야 한다.

### 5.2. 컬렉션 타입

#### 5.2.1. 배열

Array는 get(), set(), size() 등의 함수를 포함하는 클래스이다. arrayOf()으로 만들 수 있다. 특별한 타입을 명시하지 않으면 다양한 타입의 데이터를 추가할 수 있다. 

만약 한 가지 타입만 대입하고 싶다면 제네릭을 이용하거나 각 타입을 위해 제공되는 배열을 만드는 함수를 이용한다.

- 제네릭?!

  객체지향 프로그래밍 언어에서 흔히 제공하는 기능으로 소스에서 <>을 이용하여 타입을 명시하는 것을 말함. 형식 타입이라고 부름. 선언하는 곳이 아닌 이용하는 곳에서 타입을 지정하기 위한 기법.

- `i -> i*10`

  람다 표현식으로 함수를 간단하게 정의한 구문. 매개변수 값에 10을 곱해서 반환하는 함수.

#### 5.2.2. List, Set, Map

- List: 순서가 있는 데이터 집합. 중복 허용
- Set: 순서가 없고 데이터 중복 불허
- Map: 키와 값으로 이루어진 데이터 집합. 순서가 없고 중복도 불허

불변, 가변 객체를 만드는 방법이 다름.

#### 5.2.3. 이터레이터

컬렉션 타입의 데이터를 iterater()함수를 통해 이터레이터 객체로 변경하고, hasNext()와 next() 함수를 이용해 차례로 얻어서 사용하기 위한 인터페이스이다. hasNext()는 가져올 수 있는 데이터가 있는지 없는지 체크를 하고, next()는 실제 데이터를 가져올 때 사용한다.