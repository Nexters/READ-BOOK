# 책임과 메시지

## 자율적인 책임

- 객체는 스스로 정한 원칙에 따라 판단하고 행동한다.

왕이 모자 장수에게 `증언하라`고 했을 때 증언 방식은 모자 장수가 자유롭게 선택할 수 있다. 왕의 입장에서는 모자 장수가 어떤 방법으로 증언하는지는 중요하지 않다.

- 객체가 자율적이기 위해서는 객체에게 할당되는 `책임`도 `자율적`이어야 한다.

만약 왕이 `목격했던 장면을 떠올려라`, `기억을 시간 순으로 재구성 해라`, `말로 간결하게 표현해라`라고 했다면 모자 장수의 자유를 지나치게 제한한다. 결국 모자 장수 자신의
의지나 판단력이 아닌 왕의 명령에 의존하게 된다.

- 책임은 협력 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.

`설명하라`와 같이 지나치게 포괄적이고 추상적으로 책임을 정의한다면 무엇을 해야할지 모호하게 된다.

- 자율적인 책임은 어떻게가 아니라 무엇을 해야하는지 설명하는 것이다.

모자 장수가 장면을 떠올리고, 시간 순으로 재구성 한 후, 말로 표현해야 하는 책임은 `어떻게`하는지를 설명하므로 모자 장수의 선택이 제한된다.

## 메시지와 메서드

- 메시지는 다른 객체에 접근할 수 있는 유일한 방법이다.

왕과 모자 장수가 협력하기 위한 의사 소통은 오직 `증언하라`는 메시지를 전송하는 것 뿐이다.

### 메시지의 구성

- 수신자
- 메시지 이름
- 인자

수신자인 모자 장수에게 `증언하라`라는 `메시지 이름`을 전송할 때, 장소나 시간에 대한 추가적인 `인자`를 더할 수 있다. 예를 들어 왕이 어제 왕국에서 목격한 것에 대해 증언을
요청한다면 `모자장수.증언하라(어제, 왕국)` 형태의 메시지를 보내게 된다.

---

- 메시지를 처리할 수 있다. = 메시지에 해당하는 행동을 수행할 책임이 있다.

송신자는 메시지 전송으로 다른 객체에게 책임을 요청하며, 수신자는 메시지 수신으로 책임을 수행한다. 따라서 객체가 수신하는 메시지 모양이 객체의 책임을 결정한다.

- 메시지가 그대로라면 책임을 수행하는 방법은 변경할 수 있다.
- 책임을 수행하는 방법은 외부에 노출되지 않는 객체 자신의 사적인 영역이다.

모자 장수는 증언만 한다면 어떻게 수행할지 언제든 바꿀 수 있으며 왕은 변경 사실을 알 수 없다.

### 메서드

- 메시지를 처리하기 위해 내부적으로 선택하는 방법
- 어떻게 수행될지는 명시하지 않는다.
- 무엇이 실행되는지 명시한다.
- 수신자가 어떤 메서드를 선택할지 결정한다.

객체는 메시지를 수신하면 처리할 수 있는지 확인한 후 처리할 방법인 메서드를 선택한다. 선택한다는 것은 실행 코드를 컴파일 시간에 결정하는 절차 지향과 구분되는 객체 지향의
특징이다.

### 다형성

- 서로 다른 타입의 객체가 같은 메시지에 대해 다른 메서드로 메시지를 처리하는 것
- 송신자 입장에서 수신자를 구별할 필요 없이 해당 객체가 요청에 대한 책임만 수행하면 된다.

증언하라는 메시지를 받았을 때 앨리스와 모자 장수는 자율적으로 메시지를 처리한다. 어떻게 처리하든 왕의 입장에선 결과가 동일하다.

### 캡슐화

- 송신자는 수신자의 종류를 몰라도 메시지를 전송할 수 있다.
- 다형성이 수신자의 종류를 캡슐화한다.

---

다형성은 송신자와 수신자 사이의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다. 송신자가 수신자에 대해 적은 정보만 알아도 협력이 가능하면 다음의 장점이
있다.

- 협력이 유연해진다.
    - 수신자를 다른 타입의 객체로 대체해도 송신자는 알지 못한다.
- 협력이 수행되는 방식을 확장할 수 있다.
    - 책임만 완수한다면 세부 수행 방식은 수정할 수 있다.
- 협력 수행 방식을 재사용할 수 있다.
    - 다른 객체가 수신자를 대체할 수 있다.

메시지는 송신자와 수신자 사이의 결합도를 낮춰 설계를 유연하고 확장가능하며 재사용 할 수 있게 만든다. 송신자는 메시지만 바라보고 수신자의 타입을 몰라도 되므로 메서드를 송신자에게
노출시키지 않는다. 이런 낮은 결합도가 설계 품질을 높인다.

## 객체지향의 핵심

객체지향의 기본 개념은 `책임을 수행하는 자율적인 객체들의 협력으로 애플리케이션을 구축하는 것`이다. 협력을 위한 유일한 방법은 메시지 전송이다.

- 객체지향은 클래스가 아니라 객체들이 주고받는 메시지를 통해 정의된다.
- 클래스는 객체의 특성과 행위를 표현하기 위한 추상화 도구일 뿐이다.
- 클래스 정의보다 객체의 속성과 핵위를 식별하는 것이 먼저다.
- 시스템은 정적인 클래스의 집합이 아니라 메시지를 주고받는 동적인 객체의 집합이다.

메시지가 아닌 데이터로 객체를 설계하면 객체의 정의가 내부 구조가 되어 자율성이 저해된다. 내부 구조는 감춰져야 한다. 협력이라는 문맥에서 다른 객체에게 제공해야 할 메시지를
고려해라. 메시지가 객체를 선택하게 해야 한다.

### 책임-주도 설계

- 메시지가 수신자의 책임을 결정한다.

시스템의 책임을 구현하기 위해 협력할 적절한 객체를 찾아 책임을 할당한다. 책임 수행을 위해 도움이 필요하면 메시지를 결정한다. 그 후에 메시지를 수신할 객체를 선택한다.

### 묻지 말고 시켜라

송신자는 수신자를 모른 채 메시지를 처리해주길 기다린다. 객체는 다른 객체에 간섭하지 않으며 스스로 결정을 내려 책임을 수행한다.

### 메시지를 믿어라

수신할 객체의 종류는 중요하지 않다. 메시지를 이해하고 처리할 수 있는지만 신경써라.

## 객체 인터페이스

- 사용법만 알면 대상의 내부 구조나 동작 방법을 몰라도 협력할 수 있다.
- 내부 구성이나 작동 방식이 변경되어도 인터페이스를 쓰는 쪽에는 영향이 없다.
- 인터페이스만 맞으면 어떤 것과도 상호 작용할 수 있다.
- 메시지가 인터페이스를 결정한다.

왕과 모자 장수 사이엔 `증언하라` 메시지를 주고 받을 수 있는 인터페이스라는 협력 통로가 있다. `증언하다` 책임을 수행한다는 것은 인터페이스를 통해 `증언하라` 메시지를 수신할
수 있다는 의미다. 따라서 메시지가 어떤 인터페이스를 가질지 결정한다.

### 책임, 메시지, 인터페이스

- 인터페이스는 객체가 수신할 수 있는 메시지의 목록을 가진다.
- 객체는 메시지를 받으면 책임을 수행한다.
- 어떤 메시지를 수신하냐에 따라 책임과 인터페이스가 결정된다.

## 인터페이스와 구현의 분리

### 구현

- 내부 구조와 작동 방식
- 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것
    - ex. 객체의 상태, 메서드

### 분리 원칙

- 구현(객체의 상태, 메서드)을 모른 채 쉽게 상호작용 하도록 설계해야 한다.
- 객체 외부에 영향을 미치는 것은 오직 공용 인터페이스를 수정할 때 뿐이다.
- 이를 수행하기 위한 설계 방법이 변경될 부분을 객체 내부에 숨기는 캡슐화이다.

### 캡슐화

- 구현을 외부로부터 감추는 것
- 객체의 자율성을 보존한다.

객체는 상태와 행동의 조합이므로 데이터 캡슐화라고도 한다. 데이터 캡슐화가 되어야 객체는 인터페이스와 구현을 분리하고 자율성을 가진다. 인터페이스로 최소한의 의사 소통 통로를
열어둔다.

## 책임의 자율성

- 협력을 단순하게 만든다.
    - 증언을 어떻게 할지 하나하나 전달하지 않고 의도를 명확하게 표현한다.
- 외부와 내부, 구현와 인터페이스를 분리한다.
    - 증언 방식은 전적으로 모자 장수의 권한이 된다.
    - 왕은 모자 장수가 어떻게 수행하는지 알지 못한다. 즉, 캡슐화 한다.
- 내부를 변경해도 외부에 영향을 미치지 않는다.
    - 모자 장수가 증언 방식을 바꿔도 결합도가 낮아 영향을 미치지 않는다.
- 협력 대상을 유연하게 선택할 수 있다.
    - 모자 장수가 아니더라도 증언을 할 수 있다.
- 객체의 역할을 이해하기 쉬워진다.
  - 모자 장수가 증인이라는 사실만 알면 된다.
  
객체가 자율적일수록 존재 이유가 명확해지고, 목적을 달성할 책임만 가지므로 응집도가 높아진다.