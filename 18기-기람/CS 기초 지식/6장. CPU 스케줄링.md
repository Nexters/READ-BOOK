# 6장. CPU 스케줄링

**CPU**란? 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치

프로그램이 시작되어 메모리에 올라가면 프로그램 카운터(Progrma Counter: PC)라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있게 됨 -> CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행

**기계어 명령 **이란? CPU 내에서 수행되는 명령, 메모리 접근을 필요로 하는 명령, 입출력을 동반하는 명령으로 나누어볼 수 있음

- CPU 내에서 수행되는 명령 

  -> 명령 수행 속도가 매우 빠름

  - Add - CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령

- 메모리 접근을 수행하는 명령 

  -> CPU 내에서 수행되는 명령보다는 시간이 오래 소요되지만 비교적 짧은 시간에 수행할 수 있는 명령

  - Load - 메모리에 있는 데이터를 CPU로 읽어들이는 명령
  - Store - CPU에서 계산된 결괏값을 메모리에 저장하는 명령

=> 이 두 명령은 사용자 프로그램이 직접 실행할 수 있는 일반명령에 해당

**사용자 프로그램이 수행되는 과정**

1. CPU 작업(CPU 버스트) -> Add, Load, Store 명령 등을 비교적 빠른 명령
2. I/O 작업(I/O 버스트) -> 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계

각 프로그램마다 CPU버스트와 I/O버스트가 차지하는 비율이 균일하지 않다!

1. I/O 바운드 프로세스 : I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
2. CPU 바운드 프로세스 : I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스

**CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 배치**

**-> CPU 스케줄링 시 I/O 바운드 프로세스의 우선순위를 높여주는 것이 바람직**



#### 1. CPU 스케줄러

CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드

1. 비선점형 방식
   - CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 뺏기지 않는 방법
2. 선점형 방식
   - 프로세스가 CPU를 계속 사용하기를 원해도 강제로 빼앗을 수 있는 스케줄링 방법



#### 2. 디스패쳐

디스패처 : CPU 스케줄러에 의해 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드

1. 현재 수행 중이던  프로세스의 문맥을 그 프로세스의 PCB에 저장
2. 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정 수행
3. 새로운 프로세스의 문맥을 복원시킨 후에는 시스템의 상태를 사용자 모드로 전환
4. 사용자 프로그램에게 CPU의 제어권을 넘김



#### 3. 스케줄링의 성능 평가

1. 시스템 관점의 지표
   - CPU 이용률 
     - 전체 시간 중에서 CPU가 일을 한 시간의 비율
     - CPU가 일을 하지 않고 휴면 상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표
   - CPU 처리량
     - CPU 버스트를 완료한 프로세스의 개수
     - CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리
2. 사용자 관점의 지표
   - 소요시간
     - 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간
   - 대기시간
     - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
   - 응답시간
     - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간



#### 4. 스케줄링 알고리즘

##### 1) 선입선출 스케줄링

선입선출(First-Come First-Served: FCFS) 스케줄링 

-> 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식

-> CPU를 먼저 요청한 프로세스에게 CPU를 먼저 할당하고 그 프로세스가 자발적으로 CPU를 반납할 때까지 빼앗지 않음

-> 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라짐

-> 콘보이 현상: CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상 => FCFS 스케줄링의 대표적인 단점

##### 2) 최단작업 우선 스케줄링

최단작업 우선(Shortest-Job First: SJF) 스케줄링 알고리즘

-> CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식

-> 프로세스들이 준비 큐에서 기다리는 전체적인 시간이 줄어들게 됨

-> 즉, SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘 (선점형, 비선점형으로 나뉨)

1. 비선점형 방식
   - 일단 CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지 CPU를 빼앗지 않는 방식
2. 선점형 방식
   - 준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당해도, CPU 버스트가 더 짧은 프로세스가 도착할 경우 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식

프로세스들이 준비 큐에 도착하는 시간이 불규칙한 환경에서는 선점형 방식이 프로세스들의 평균 대기시간을 최소화하는 **최적의 알고리즘** => 일반적인 시분할 환경에서는 중간중간 새로운 프로세스가 도착하는 경우가 발생하므로 선점형 방식이 굿

하지만 이게 꼭 좋은 방식이라고는 할 수 없음. CPU 버스트가 긴 프로세스가 준비 큐에 줄 서서 무한정 기다리는 문제가 발생할 수도 있기 때문.

##### 3) 우선순위 스케줄링

우선순위 스케줄링: 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식

**우선순위값의** **기준**

1. CPU 버스트 시간 -> 이렇게 하면 SJF 알고리즘과 동일한 의미
2. 시스템과 관련된 중요한 작업을 수행하는 프로세스

**우선순위 스케줄링의 문제점**

1. 기아 현상
   - 우선순위가 높은 프로세스가 계속 도착하는 상황에서 우선순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다리게 됨
   - 이를 위해 노화기법을 사용함 (기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 하는 방법)

##### 4) 라운드 로빈 스케줄링

앞서 소개된 세개의 스케줄링 방식과 달리 시분할 시스템의 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식

각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며, 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당

여러 이질적인 프로세스가 같이 실행되는 환경에서 효과적

라운드 로빈 스케줄링의 기본적인 목적은 **CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버트스 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것**

##### 5) 멀티레벨 큐

준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법 -> 프로세스들이 CPU를 기다리기 위해 한 줄로 서는 것이 아니라 여러 줄로 서는 것

대화형 작업을 담기 위한 전위큐, 계산 위주의 작업을 담기 위한 후위 큐로 분할하여 운영됨

멀티레벨 큐에서는 큐 자체에 대한 스케줄링도 필요함

1. 고정 우선순위 방식
2. 타임 슬라이스 방식

##### 6) 멀티레벨 피드백 큐

CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능함

멀티레벨 피드백 큐를 정의하는 요소들

1. 큐의 수
2. 각 큐의 스케줄링 알고리즘
3. 프로세스를 사우이 큐로 승격시키는 기준
4. 프로세스를 하위 큐로 강등시키는 기준
5. 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준

##### 7) 다중처리기 스케줄링

CPU가 여러 개인 시스템. 프로세스를 준비 큐에 한 줄로 세워서 각 CPU가 알아서 다음 프로세스를 꺼내어가도록 할 수 있음

1. 대칭형 다중처리
   - 각 CPU가 각자 알아서 스케줄링을 결정하는 방식
2. 비대칭형 다중처리
   - 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 거기에 따라 움직이는 방식

##### 8) 실시간 스케줄링

각 작업마다 주어진 데드라인이 있어 정해진 데드라인 안에 반드시 작업을 처리해야 하는 스케줄링

1. 경성 실시간 시스템
   - 미사일 발사, 원자로 제어 등 시간을 정확히 지켜야 하는 시스템
2. 연성 실시간 시스템
   - 멀티미디어 스트리밍 시스템
   - 데드라인이 지켜지지 않는다고 해서 위험한 상황이 발생하지는 않음



#### 5. 스케줄링 알고리즘의 평가

1. 큐잉모델
   - 주로 이론가들이 수행하는 방식
   - 복잡한 수학적 계산으로 각종 성능지표를 계산
2. 구현 및 실측
   - 이론가와 정반대인 구현가들이 수행할 수 있는 방식
   - 운영체제 커널의 소스 코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정을 필요로 함
3. 시뮬레이션
   - 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지를 확인

