## 5장. 프로세스 관리

#### 1. 프로세스의 개념

**프로세스란? ** 실행 중인 프로그램 (program in execution)

프로세스 플로우(?)

1. 디스크에 실행파일 형태로 존재하던 프로그램이 있음
2. 이 프로그램이 메모리에 올라가서 실행되면 프로세스가 됨
3. 프로세스는 CPU를 획득해서 자신의 코드를 수행하기도 하고, 때로는 CPU를 반환하고 입출력 작업을 수행함
4. 임무를 다 수행하고 나면 종료되어 사라지게 됨 (Q. 어디에서 사라지는거지? 메모리에서?)

**프로세스의 문맥**이 포함하는 것

- 프로세스의 주소공간
- 레지스터에 어떤 값을 가지고 있었는지
- 시스템 콜 등을 통해 커널에서 수행한 일의 상태
- 프로세스에 관해 커널이 관리하고있는 각종 정보

**프로세스 문맥** 분류

1. 하드웨어 문맥 
2. 프로세스 주소 공간
3. 커널상의 문맥



#### 2. 프로세스의 상태

1. 실행
   - 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태
   - 여러 프로세스가 동시에 수행된다고 해도 실제로 실행 상태에 있는 프로세스는 매 시점 하나뿐
2. 준비
   - 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
3. 봉쇄
   - CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태
   - ex. 프로세스가 요청한 입출력 작업이 진행 중인 경우

- 프로세스의 상태를 구분하는 이유 : 컴퓨터의 자원을 효율적으로 관리하기 위해서

3가지 상태 이외에도 프로세스의 일시적 상태를 2가지로 구분짓기도 함

1. 시작 상태
   - 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
2. 완료 상태
   - 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태



#### 3. 프로세스 제어블록

- 프로세스 제어블록(PCB): 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
- PCB 요소
  - 프로세스의 상태 : CPU를 할당해도 되는지 여부를 결정하기 위해 필요
  - 프로그램 카운터의 값 : 다음에 수행할 명령의 위치를 가리킴
  - CPU 레지스터의 값 : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄
  - CPU 스케줄링 정보
  - 메모리 관리 정보
  - 자원 사용 정보
  - 입출력 상태 정보



#### 4. 문맥교환

- 문맥교환 : 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정

1. 사용자 프로세스가 CPU를 할당받고 실행
2. 타이머 인터럽트 발생
3. CPU 제어권이 운영체제로 넘어감
4. 운영체제는 타이머 인터럽트 처리루틴으로 감
5. 처리루틴에서 직전까지 수행 중이던 프로세스의 문맥을 저장하고 새롭게 실행시킬 프로세스에게 CPU 이양
6. 1~5가 문맥교환의 과정. 이 과정에서 원래 수행 중이던 프로세스는 준비 상태로 바뀜
7. 새롭게 CPU를 할당받은 프로세스는 실행 상태가 됨

문맥교환은 타이머 인터럽트가 발생하는 경우 외에 실행 중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우에도 발생



#### 5. 프로세스를 스케줄링하기 위한 큐

- 운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU 할당
- CPU를 기다리는 프로세스들을 줄 세우는 준비 큐 외에도 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐를 둠
- 이외에도 작업 큐를 추가로 유지
  - 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐
  - 프로세스의 상태과 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속함
- 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행



#### 6. 스케줄러

- 스케줄러: 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드
- 스케줄러의 종류
  - 장기 스케줄러
    - 작업 스케줄러라고도 부름
    - 시작 상태의 프로세스들 중 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할
    - 프로세스에게 메모리를 할당하는 문제에 관여하게 됨
    - 가끔 호출되기 때문에 상대적으로 속도가 느려도 괜찮음
  - 단기 스케줄러
    - CPU 스케줄러라고도 함
    - 준비 상태의 프로세스 중에서 어떤 프로세스를 실행 상태로 만들 것인지
    - 즉, 준비 큐에 있는 여러 프로세스들 중 어떤 프로세스에게 CPU를 할당할 것인가를 결정
    - 단기 스케줄러는 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 함
  - 중기 스케줄러
    - 너무 많은 프로세스에게 메모리를 할당해 시스템 성능이 저하되는 경우를 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러
    - 프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역할

하지만 현대의 시분할 시스템에서 사용되는 운영체제는 일반적으로 장기 스케줄러를 쓰지 않음. 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많음. 



#### 7. 프로세스의 생성

시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성함

- 부모 프로세스: 프로세스를 생성한 프로세스

- 자식 프로세스: 새롭게 생성된 프로세스

즉, 부모 프로세스가 자식 프로세스를 생성하는 것. 이런 방식을 통해 프로세스는 족보와 같은 계층을 형성

- 프로세스가 수행되는 모델

  - 부모와 자식이 공존하며 수행되는 모델
    - 자식과 부모가 같이 CPU를 획득하기 위해 경쟁하는 관계
  - 자식이 종료될때까지 부모가 기다리는 모델
    - 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지 않고 봉쇄 상태에 머물러 있다가, 자식 프로세스가 종료되면 그제서야 부모 프로세스가 준비 상태가 되어 다시 CPU를 얻을 권한이 생김

  

#### 8.프로세스 간의 협력

프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않음

부모 프로세스가 자식 프로세스를 생성할 때 자식 프로세스가 부모 프로세스의 주소 공간을 복제하긴 하지만 생성이 완료된 후부터는 각자 자신의 독자적인 주소 공간만을 참조해 코드를 수행 -> 독립적인 관계

경우에 따라서 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있음. 때문에 운영체제는 프로세스 간의 협력 매커니즘을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 함

- IPC 매커니즘

  - 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신

  - 의사소통 기능과 함께 동기화를 보장해줘야함

  - 프로세스들 간의 통신과 동기화를 이루기 위한 매커니즘

  - 방식

    - 메시지 전달 방식
      - 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고받으면서 통신하는 방식
      - 커널이 의사소통 징검다리같은 역할인데, send, receive라는 두 가지 연산을 제공함
      - 메시지의 전송 대상이 다른 프로세스인지 아니면 메일박스라는 일종의 저장공간인지에 따라 다시 1) 직접통신, 2) 간접통신 으로 나뉨
    - 공유메모리 방식

    -> 이 두 방식의 차이는 프로세스 사이에 공유 데이터를 사용하는가, 사용하지 않는가에 있음

    

