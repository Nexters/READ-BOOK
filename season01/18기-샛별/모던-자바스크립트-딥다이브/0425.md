## 19.6 객체 생성 방식과 프로토타입의 결정

- 모든 객체는 추상 연산 `OrdinaryObjectCreate` 에 의해 생성된다
- 추상 연산 `OrdinaryObjectCreate` 는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다. 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달되면 프로퍼티를 객체에 추가하고 인수로 전달받은 프로토타입을 객체의 [[Prototype]] 내부 슬롯에 할당한다.

### 객체 리터럴에 의해 생성된 객체의 프로토타입

- 자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때 프로토타입으로 `Object.prototype` 을 전달하며 추상 연산 `OrdinaryObjectCreate` 를 호출한다.

### Object 생성자 함수에 의해 생성된 객체의 프로토타입

- Object 생성자 함수를 인수 없이 호출하면 빈 객체가 생성된다.
- Object 생성자 함수를 호출하면 `OrdinaryObjectCreate` 를 호출되며 이때 전달되는 프로토타입은 `Object.prototype` 이다.

### 생성자 함수에 의해 생성된 객체의 프로토타입

- `new` 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 생성자 함수의 prototype 프로퍼티에 바인딩된 객체가 프로토타입으로 전달하며 `OrdinaryObjectCreate` 가 호출된다.

## 19.7 프로토타입 체인

- 프로토타입의 프로토타입은 언제나 `Object.prototype` 이다.
- **프로토타입 체인** : 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 **없다면** **[[Prototype]] 내부 슬롯의 참조**를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.
- 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘
- 모든 객체는 `Object.prototype` 을 상속받으므로 **프로토타입 체인의 종점**이다.
- `Object.prototype` 의 프로토타입은 `null` 이다.

```jsx
프로토타입 체인 : 상속과 프로퍼티 검색을 위한 메커니즘
스코프 체인 : 식별자 검색을 위한 메커니즘

⭐️ 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용된다!
```

## 19.8 오버라이딩과 프로퍼티 섀도잉

- **프로퍼티 섀도잉** : 상속관계에 의해 프로퍼티가 가려지는 현상
    - 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티로 추가하며 프로토타입 프로퍼티는 가려짐!
- 프로토타입 프로퍼티를 변경 또는 삭제하려면 프로토타입에 직접 접근해야 한다.

## 19.10 `instanceof` 연산자

```jsx
객체 instanceof 생성자 함수
// 우변의 피연산자가 함수가 아닌 경우 TypeError 발생!
```

- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 그렇지 않은 경우 false
- instanceof 연산자는 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.

## 19.11 직접 상속

### `Object.create`에 의한 직접 상속

- `Object.create` 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
- 다른 객체 생성 방식과 마찬가지로 추상 연산 `OrdinaryObjectCreate` 를 호출한다.
- 첫 번째 매개변수 : 생성할 객체의 프로토타입으로 지정할 객체
- 두 번째 매개변수 : 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체

```jsx
/**
 * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환
 * @param {object} prototype - 생성할 객체의 프로토타입으로 지정할 객체
 * @param {object} [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체
 * @returns {object} 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체
*/

Object.create(prototype[, propertiesObject])
```

- `Object.create` 의 장점
    - new 연산자 없이 객체 생성
    - 프로토타입을 지정할 수 있음
    - 객체 리터럴에 의해 생성된 객체도 상속받을 수 있음

- `Object.create` 메서드로 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있으므로 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않는다.

### 객체 리터럴 내부에서 __proto__ 에 의한 직접 상속

- ES6에서는 객체 리터럴 내부에서 __proto__ 접근자 프로퍼티를 사용하여 직접상속 구현

```jsx
const obj = {
	y: 20,
	__proto__: myProto
};
```

## 19.12 정적 프로퍼티/메서드

- **`정적 프로퍼티/메서드`** 는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말하며 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.

## 19.13 프로퍼티 존재 확인

### in 연산자

- 객체 내에 특정 프로퍼티가 존재하는지 여부 확인
- 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의 필요
- ES6에서 도입된 `Reflect.has` 도 동일하게 동작한다.

### Object.prototype.hasOwnProperty 메서드

- 객체에 특정 프로퍼티가 존재하는지 확인
- 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true 반환
- 상속받은 프로토타입의 프로퍼티 키인 경우에는 false 반환

## 19.14 프로퍼티 열거

### for ... in 문

```jsx
for (변수선언문 in 객체) { ... }
```

- 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중 [[Enumberable]] 값이 true인 경우에만 열거됨
- 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않음
- 순서를 보장하지 않는 것이 원칙
- 그러나 대부분의 모던 브라우저는 순서를 보장하고 숫자(문자열이지만)인 키는 정렬 실시

### Object.keys/values/entries 메서드

- 객체 자신의 고유 프로퍼티만 열거하기 위해서는 `for ... in` 문 보다는 Object.keys/values/entries 메서드를 사용하는 것을 권장한다.