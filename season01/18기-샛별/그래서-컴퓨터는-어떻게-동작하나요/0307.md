# Chapter 40 ~ 46 (149p~172p)

## 40. 명령어

- 명령어 레지스터에 들어가는 바이트 데이터는 제어 장치가 어떤 일을 해야 하는지 말해준다. 명령어 레지스터에 넣은 비트 패턴 자체가 코드이며 이 코드를 `instruction code` 라고 한다.

## 41. ALU 명령어

- ALU 명령어는 컴퓨터가 처리할 수 있는 가장 융통성 있는 명령어 종류로 기본적인 연산은 총 8가지이고, 가용할 수 있는 레지스터는 총 4개이다.
- 명령어 레지스터의 0번 비트가 1로 시작하면 그 명령어는 ALU 명령어에 속한다.
- 단일 입력을 받는 경우 : Reg A에 바이트를 입력받아 연산 결과를 Reg B에 저장
- 2입력 연산인 경우 : 입력으로 Reg A, Reg B를 사용하고 결과를 Reg B에 저장

### ALU 명령어를 실행하기 위한 3가지 작업

1. `Reg B`에 있는 데이터를 `TMP`로 이동
2. 어떤 연산을 할지 `ALU`에 말해주고 `Reg A`를 버스에 출력하면 해당 연선 결과를 `ACC`에 저장
3. `ACC`에 있는 결과를 `Reg B`로 이동

## 42. 로드/저장 명령어

### 로드 명령어 (load)

- 램에 들어 있는 바이트 데이터를 레지스터로 이동할 때 사용

### 저장 명령어 (store)

- 레지스터에 들어 있는 바이트 데이터를 램으로 이동할 때 사용

## 43. 데이터 명령어

- 램의 어떤 주소에서 바이트 데이터를 하나 가져와서 레지스터에 로드하는 기능
- 데이터 명령어로 **바이트 데이터를 가져오기 위해 지정하는 램의 주소**는 로드 명령어에서 지정하는 주소와 다른 공간을 사용한다!
- 데이터 명령어에서 데이터는 다음 수행될 명령어가 이썽야 할 자리에서 가져오므로 실제로는 2바이트 크기이다. 첫 번째 바이트는 명령어 자체, 두 번째 바이트는 특정 레지스터에 저장될 데이터를 가리킨다.

## 44. 위대한 도약 2 : 분기 명령어

- 분기 명령어는 IAR의 내용을 직접 바꿀 수 있다.
- `레지스터 분기 명령어` : 레지스터 B에 들어 있는 내용을 IAR로 옮김
  - **JMPR RB** : RB에 들어 있는 램의 주소로 분기

## 45. 직접 분기 명령어 (jump instruction)

- 2비이트로 구성되어 두 번째 바이트에 램의 번지수를 적는다.
- RAM의 번지수를 이용해 IAR의 내용을 직접 변경하고 분기하여 다음 명령어를 가져온다.