> p22-149



1. 코드는 이해하기 쉬워야 한다.

- 코드는 다른 사람이 그것을 이해하는 데 들이는 시간을 최소화하는 방식으로 작성되어야 한다.



## ONE 표면적 수준에서의 개선

표면적 수준이란 좋은 이름을 짓고, 좋은 설명을 달고, 코드를 보기 좋게 정렬하는 따위를 의미한다.



2. 이름에 정보 담기

- 특정한 단어 고르기

이 방법 중 하나는 매우 구체적인 단어를 선택하여 '무의미한' 단어를 피하는 것이다.

예를 들어, "get"은 지나치게 보편적이다.

```
def getPage(url):
	...
```

위에서 get은 별다른 의미를 전달하지 않는다. 이 메소드는 로컬 캐시, 데이터베이스, 아니면 인터넷 중 어디에서 페이지를 가져오는 것인가?

만약 인터넷이라면, FetchPage(), DownloadPage() 가 더 의미 있는 이름이 될 것이다.

또, 만약 Stop() 이라는 메소드 명을 사용한다고 했을 때, 정확히 무엇을 수행하는지에 따라서 더 의미 있는 이름을 사용할 수 있다.

다시는 되돌릴 수 없는 최종 동작을 수행한다면 Kill(), 만약 Resume()을 호출해서 다시 돌이킬 수 있다면 Pause()가 더 좋을 것이다.

- 추상적인 이름보다 구체적인 이름을 선호하라

예를 들어 서버가 어느 TCP/IP 포트를 사용할 수 있는지 검사하는 ServerCanStart()라는 내부 메소드가 있다. 이 이름은 다소 추상적이다. 더 구체적으로 CanListenOnPort()로 메소드가 수행하는 일을 직접적으로 설명할 수 있다.

- 추가적인 정보를 이름에 추가하기

단위나 다른 중요한 속성들을 이름에 표시해주자.

`start_ms` 밀리초 단위를 표현

`untrustedUrl` 안전하지 않은 입력 -> 추가 처리 후 `trustedUrl`

- 이름은 얼마나 길어야 하는가?

약어 사용은 좋지 않다. 시간이 흐르면, 이름을 작명한 본인에게도 비밀스럽고 위협적인 모습을 지닌다.

자동 완성 기능이 있으니 길이에 연연하지 않고 최대한 의미를 전달하는 변수명을 짓자. 다만 불필요한 단어는 제거하자.



3. 오해할 수 없는 이름들

`filter()` -> 대상을 '고르는' 것이라면 `select()`, 대상을 '제거하는' 것이라면 `exclude()` 등으로 표현

- 경계를 포함하는 한계값을 다룰 때

`min()` 해당 값을 포함한 최솟값

`max()` 해당 값을 포함한 최댓값

- 경계를 포함하는 범위

`first()` 해당 값을 포함한 범위의 첫 값

`last()` 해당 값을 포함한 범위의 끝 값

- 경계를 포함/배제하는 범위

`begin()` 해당 값을 포함한 범위의 첫 값

`end()` 해당 값을 배제한 범위의 첫 값

모호하지만 이는 적어도 C++의 표준 라이브러리와 배열에서 관용구처럼 사용되므로 최선의 선택이다

- 불리언 변수

일반적으로 is, has, can, should와 같은 단어를 사용하면 의미가 더 명확해진다.

- 사용자의 기대에 부응하기

어떤 이름의 의미를 이미 특정한 방식으로 이해해서 실제로 다른 의미가 있음에도 오해를 초래할 때가 있다. 이런 경우에는 '굴복하고' 그것이 일반적인 의미를 갖도록 하는 게 좋다.

"함수를 호출하는 사람의 잘못이지! 관련된 문서를 주의 깊게 읽었어야 해"라고 생각할지도 모른다. 하지만 일반적인 의미로 생각되지 않는 것이 더 의외인 것이다.



4. 미학

미학적으로 보기 좋은 코드가 사용하기 더 편리하다는 사실은 명백하다.

- 일관성과 간결성을 위해서 줄 바꿈을 재정렬하기 (추가적인 줄 바꿈을 일관성 있게 넣어주고 주석의 들여쓰기 위치를 맞추는 등)

- 메서드를 활용하여 불규칙성을 정리하고 가독성을 높인다
- (그 순서가 코드의 동작에 상관이 없음에도) 의미 있는 순서를 선택하고 일관성 있게 사용하라
  가장 중요한 것 -> 덜 중요한 것 / 알파벳 순



5. 주석에 담아야 하는 대상

- 설명 자체를 위한 설명을 달지 말라

무가치한 주석을 달지 말라, 주석이 필요한 변수명 대신 이름에서 뜻을 이해할 수 있는 변수명을 작성하라

- 생각을 기록하라 - 코드의 결함을 설명하라

```
// 이 주먹구구식 논리는 몇 가지 단어를 생략할 수 있다. 상관없다. 100% 해결은 쉽지 않다.
```

이 주석을 통해 뭔가 버그를 발견한 사용자가 테스트 케이스를 짜거나, 버그를 수정하는 데 시간을 허비하지 않을 수 있다.

```
// 이 클래스는 점점 엉망이 되어가고 있다. 어쩌면 'ResourceNode' 하위클래스를 만들어서 정리해야 할지도 모르겠다.
```

이 주석은 코드가 엉망이라는 사실을 밝히고 어떻게 수정해야 하는지 알려준다.

```
// TODO: 더 빠른 알고리즘을 사용하라.
// TODO: JPEG 말고 다른 이미지 포맷도 처리해야 한다.
```

TODO: 아직 하지 않은 일

FIXME: 오동작을 일으킨다고 알려진 코드

HACK: 아름답지 않은 해결책

XXX: 위험! 여기 큰 문제가 있다

TextMate: ESC

위의 표현들이 관용적으로 사용된다.

- 상수에 대한 설명

상수에는 종종 '사연'이 존재하기 마련이다.

```
NUM_THREADS = 8 // 2*num_processors보다 크거나 같으면 된다.

// 합리적인 한계를 설정하라 - 그렇게 많이 읽을 수 있는 사람은 어차피 없다.
const int MAX_RSS_SUBSCRIPTIONS = 1000;
```

- 코드를 읽는 사람의 입장이 되어라.

기본적으로 '앞질러 생각해서' 코드의 어떤 문제점들을 미리 예측하는 것이다.

- 코드에 블록별로 주석을 달아 세부 코드를 읽다가 나무만 보고 숲은 못 보는 실수를 저지르지 마라.



6. 명확하고 간결한 주석 달기

- 'it', 'this' 등의 대명사는 여러 가지를 가리킬 수 있으므로 사용하지 않는 것이 좋다.
- 동작을 명확하게, 구체적으로 설명하라.



## TWO 루프와 논리를 단순화하기

7. 읽기 쉽게 흐름제어 만들기

- 조건문에서 인수의 순서

```
if length >= 10:
```

(값이 더 유동적인 '질문을 받는' 표현) == (더 고정적인 값으로 '비교 대상'으로 사용되는 표현)

- if/else 블록의 순서
  - 부정이 아닌 긍정을 다루어라. `if(!deug)`가 아니라 `if(debug)`를 선호하자.
  - 간단한 것을 먼저, 더 흥미롭고 확실한 것을 먼저 처리하라

- 함수 중간에서 반환하기



8. 거대한 표현을 잘게 쪼개기

대왕오징어는 매우 놀랍고 지혜로운 동물이다. 하지만 완벽해 보이는 몸에는 한 가지 치명적인 결함이 있다. 바로 식도를 감싸는 도넛 모양의 뇌다. 이 때문에 폭식하면 뇌가 손상된다.

지나치게 커다란 '덩어리' 코드는 이와 동일한 효과가 있다. 코드의 표현이 커질수록 이해하기는 더 어렵다.



- 설명 변수

```
username = line.split(":"[0]).strip()
if username:
	...
```

- 요약 변수

```java
final boolean user_owns_document = (request.user.id == document.owner_id)
if (user_owns_document) {
	...
}
```

- 드 모르간의 법칙 (ㅋㅋ)

not을 분배하고 and/or을 바꿔라, 혹은 not을 밖으로 빼내라

```
if (!(file_exists && !is_protected)):

if (!file_exists || is_protected):
```

- 쇼트 서킷 논리 오용 말기

쇼트 서킷 평가: (a || b)에서 a가 참이면 b는 평가하지 않는다. 이는 매우 편리하지만 때로는 오용될 수 있다.



9. 변수와 가독성

앞에서 '설명 변수'와 '요약 변수'로 코드의 가독성을 높이는 방법에 대해 이야기했다. 이번엔 '도움되지 않는 변수'를 제거하는 방법에 대해 이야기한다.

- 불필요한 임시 변수들

```
now = datetime.datetime.now()
```

이미 그 자체로 명확한 datetime을 굳이 변수화 하지 않아도 된다.

- 중간 결과 삭제하기 - 결과를 얻고 곧바로 삭제한다

- 흐름 제어 변수 제거하기

flag 등의 흐름 제어 변수는 프로그램의 구조를 잘 설계하면 제거할 수 있을 때가 많다.

- 변수의 범위를 좁혀라

전역 변수뿐만 아니라 모든 변수의 범위를 좁히는 일은 언제나 좋다.

많은 메소드를 정적 static으로 만들어서 클래스 멤버 접근을 제한해라. '독립적'이라는 사실을 알려주는 매우 좋은 방법이다.

커다란 클래스를 작은 클래스로 나누어라. 이 때 서로의 멤버를 참조하지 않게 만들어야 한다.

- 정의를 아래로 옮기기

변수의 정의나 함수가 블록의 윗부분에서 이루어지는 것은, 지금 당장 사용되지 않는 변수조차 일단 염두에 두게 강제하므로 좋지 않다.

각각의 정의는 실제 사용 직전의 위치로 옮기는 게 좋다.



---

어렵지 않은 내용들이지만 실제 코드를 작성하면서 간과하기 쉬운 내용들인 것 같다.